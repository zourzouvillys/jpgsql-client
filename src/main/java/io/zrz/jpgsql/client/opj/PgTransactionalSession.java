// Generated by delombok at Tue Sep 22 10:54:18 PDT 2020
package io.zrz.jpgsql.client.opj;

import java.sql.SQLException;
import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.LinkedTransferQueue;
import java.util.concurrent.TimeUnit;

import org.reactivestreams.Publisher;

import com.google.common.io.ByteSource;

import io.netty.buffer.ByteBuf;
import io.reactivex.rxjava3.core.BackpressureStrategy;
import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.core.FlowableEmitter;
import io.reactivex.rxjava3.schedulers.Schedulers;
import io.reactivex.rxjava3.subjects.SingleSubject;
import io.zrz.jpgsql.client.PostgresClient;
import io.zrz.jpgsql.client.PostgresqlUnavailableException;
import io.zrz.jpgsql.client.Query;
import io.zrz.jpgsql.client.QueryParameters;
import io.zrz.jpgsql.client.QueryResult;
import io.zrz.jpgsql.client.SessionTxnState;
import io.zrz.jpgsql.client.TransactionalSession;
import io.zrz.jpgsql.client.TransactionalSessionDeadlineExceededException;
import io.zrz.sqlwriter.Tuple;

/**
 * a seized connection for a consumer who is performing multiple operations on a txn.
 */
class PgTransactionalSession implements TransactionalSession, Runnable {
  @java.lang.SuppressWarnings("all")
  private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(PgTransactionalSession.class);


  private static final class Work {
    private final Query query;
    private final QueryParameters params;
    private final FlowableEmitter<QueryResult> emitter;

    @java.lang.SuppressWarnings("all")
    public Work(final Query query, final QueryParameters params, final FlowableEmitter<QueryResult> emitter) {
      this.query = query;
      this.params = params;
      this.emitter = emitter;
    }

    @java.lang.SuppressWarnings("all")
    public Query getQuery() {
      return this.query;
    }

    @java.lang.SuppressWarnings("all")
    public QueryParameters getParams() {
      return this.params;
    }

    @java.lang.SuppressWarnings("all")
    public FlowableEmitter<QueryResult> getEmitter() {
      return this.emitter;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    public boolean equals(final java.lang.Object o) {
      if (o == this) return true;
      if (!(o instanceof PgTransactionalSession.Work)) return false;
      final PgTransactionalSession.Work other = (PgTransactionalSession.Work) o;
      final java.lang.Object this$query = this.getQuery();
      final java.lang.Object other$query = other.getQuery();
      if (this$query == null ? other$query != null : !this$query.equals(other$query)) return false;
      final java.lang.Object this$params = this.getParams();
      final java.lang.Object other$params = other.getParams();
      if (this$params == null ? other$params != null : !this$params.equals(other$params)) return false;
      final java.lang.Object this$emitter = this.getEmitter();
      final java.lang.Object other$emitter = other.getEmitter();
      if (this$emitter == null ? other$emitter != null : !this$emitter.equals(other$emitter)) return false;
      return true;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    public int hashCode() {
      final int PRIME = 59;
      int result = 1;
      final java.lang.Object $query = this.getQuery();
      result = (result * PRIME) + ($query == null ? 43 : $query.hashCode());
      final java.lang.Object $params = this.getParams();
      result = (result * PRIME) + ($params == null ? 43 : $params.hashCode());
      final java.lang.Object $emitter = this.getEmitter();
      result = (result * PRIME) + ($emitter == null ? 43 : $emitter.hashCode());
      return result;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    public java.lang.String toString() {
      return "PgTransactionalSession.Work(query=" + this.getQuery() + ", params=" + this.getParams() + ", emitter=" + this.getEmitter() + ")";
    }
  }

  private static final Duration LOOP_WAIT = Duration.ofSeconds(1);
  private static final Duration MAX_IDLE = Duration.ofSeconds(5);
  private final SingleSubject<SessionTxnState> txnstate = SingleSubject.create();
  private final LinkedTransferQueue<Work> workqueue = new LinkedTransferQueue<>();
  // if we are accepting work still
  private boolean accepting = true;
  private final PgThreadPooledClient pool;

  PgTransactionalSession(PgThreadPooledClient pool) {
    this.pool = pool;
  }

  /*
   * provide the handle for observing our state.
   */
  @Override
  public CompletableFuture<SessionTxnState> txnstate() {
    final CompletableFuture<SessionTxnState> future = new CompletableFuture<>();
    this.txnstate.doOnError(future::completeExceptionally).subscribe(future::complete);
    return future;
  }

  /*
   * called from the consumer thread. we still use a Flowable so that we can stop fetching from the server on huge
   * datasets if the consumer isn't keeping up. however, we need to make it hot - otherwise it will never start, which
   * would be unexpected for submitting a simple "COMMMIT". although consumers should really be checkign result status
   * ... ahem.
   */
  @Override
  public Flowable<QueryResult> submit(Query query, QueryParameters params) {
    if (!this.accepting) {
      throw new IllegalStateException(String.format("This session is no longer active"));
    }
    final Flowable<QueryResult> flowable = Flowable.create(emitter -> {
      log.debug("added work item: {}", query);
      this.workqueue.add(new Work(query, params, emitter));
    }, BackpressureStrategy.BUFFER);
    return flowable.publish().autoConnect().observeOn(Schedulers.computation()).doOnEach(e -> log.debug("notif: {}", e));
  }

  @Override
  public Publisher<Long> copyTo(String sql, Publisher<ByteBuf> data) {
    throw new IllegalArgumentException();
  }

  /*
   * run in the thread with the connection any exception propogated from here will dispatch an onError on the txnstate.
   */
  private void run(PgLocalConnection conn) throws SQLException, InterruptedException {
    log.debug("starting txn");
    Instant startidle = Instant.now();
    while (true) {
      final Work work = this.workqueue.poll(LOOP_WAIT.toNanos(), TimeUnit.NANOSECONDS);
      if (work != null) {
        if (work.getEmitter() == null) {
          log.debug("no emitter - rolling back, work was {}", work);
          conn.rollback();
        } else {
          log.info("processing work item {}", work);
          startidle = null;
          conn.execute(work.getQuery(), work.getParams(), work.getEmitter());
        }
        startidle = Instant.now();
      } else {
        final Duration idle = Duration.between(startidle, Instant.now());
        if (idle.compareTo(MAX_IDLE) > 0) {
          log.warn("aborting transaction due to {} idle", idle);
          this.accepting = false;
          conn.rollback();
          this.txnstate.onError(new TransactionalSessionDeadlineExceededException());
          return;
        }
        log.warn("idle {} loops in open transaction", Duration.between(startidle, Instant.now()));
      }
      log.debug("txn state now {}", conn.transactionState());
      switch (conn.transactionState()) {
      case IDLE: 
        this.accepting = false;
        this.txnstate.onSuccess(SessionTxnState.Closed);
        if (!this.workqueue.isEmpty()) {
          log.warn("work queue is not empty after session completed");
          this.workqueue.forEach(e -> {
            if (e.emitter != null) e.emitter.onError(new IllegalStateException("Session has already completed (in IDLE)"));
          });
        }
        return;
      case FAILED: 
        this.accepting = false;
        this.txnstate.onSuccess(SessionTxnState.Error);
        if (!this.workqueue.isEmpty()) {
          log.warn("work queue is not empty after session completed");
          this.workqueue.forEach(e -> {
            if (e.emitter != null) e.emitter.onError(new IllegalStateException("Session has already completed (in FAILED) for " + e.getQuery()));
          });
        }
        return;
      case OPEN: 
        if (!this.accepting && this.workqueue.isEmpty()) {
          // rollback - which will terminate us.
          conn.rollback();
        }
        // still going ..
        break;
      }
    }
  }

  /*
   * called when the job is allocated - runs in the thread.
   */
  @Override
  public void run() {
    log.trace("running query");
    try {
      this.run(PgConnectionThread.connection());
    } catch (final SQLException ex) {
      // Any propagated SQLException results in the connection being closed.
      log.warn("connection failed: {}", ex.getMessage(), ex);
      this.accepting = false;
      PgConnectionThread.close();
      this.txnstate.onError(new PostgresqlUnavailableException(ex));
    } catch (final Exception ex) {
      log.warn("connection failed: {}", ex.getMessage(), ex);
      this.accepting = false;
      // TODO: release the transaction, but don't close the connection.
      this.txnstate.onError(ex);
    }
  }

  /*
   * rollback the transaction if there is one.
   */
  @Override
  public void close() {
    // Preconditions.checkState(this.accepting, "session is no longer active");
    if (accepting) {
      this.accepting = false;
      this.workqueue.add(new Work(this.pool.createQuery("ROLLBACK"), null, null));
    }
  }

  /*
   * called from the consumer thread. jusr raise the failure, nothing else.
   */
  public void failed(Exception ex) {
    this.accepting = false;
    this.txnstate.onError(ex);
  }

  @Override
  public Query createQuery(String sql, int paramcount) {
    return this.pool.createQuery(sql, paramcount);
  }

  @Override
  public Query createQuery(List<Query> combine) {
    return this.pool.createQuery(combine);
  }

  @Override
  public Flowable<QueryResult> fetch(int batchSize, Tuple query) {
    throw new IllegalArgumentException();
  }

  @Override
  public PostgresClient client() {
    return pool;
  }

  @Override
  public Publisher<Long> copyTo(String sql, ByteSource source) {
    throw new IllegalArgumentException();
  }
}
