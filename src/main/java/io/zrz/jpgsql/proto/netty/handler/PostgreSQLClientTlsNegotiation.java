// Generated by delombok at Tue Sep 22 10:54:18 PDT 2020
package io.zrz.jpgsql.proto.netty.handler;

import java.util.HashMap;

import javax.net.ssl.SSLEngine;

import io.netty.buffer.ByteBuf;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.logging.LoggingHandler;
import io.netty.handler.ssl.SslHandler;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;
import io.zrz.jpgsql.proto.client.PgConnection;
import io.zrz.jpgsql.proto.netty.ProtoUtils;
import io.zrz.jpgsql.proto.wire.PostgreSQLPacket;

/**
 * Sends the initial payload when the channel is opened.
 */
public class PostgreSQLClientTlsNegotiation extends SimpleChannelInboundHandler<ByteBuf> {
  @java.lang.SuppressWarnings("all")
  private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(PostgreSQLClientTlsNegotiation.class);
  private boolean established = false;
  private SSLEngine sslEngine;
  private HashMap<String, String> params;
  private SimpleChannelInboundHandler<PostgreSQLPacket> handler;
  private String password;

  public PostgreSQLClientTlsNegotiation() {
  }

  public PostgreSQLClientTlsNegotiation(final SSLEngine sslEngine, final HashMap<String, String> params, final SimpleChannelInboundHandler<PostgreSQLPacket> handler, final String password) {
    this.sslEngine = sslEngine;
    this.params = params;
    this.handler = handler;
    this.password = password;
  }

  @Override
  protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf msg) throws Exception {
    final byte b = msg.readByte();
    switch (b) {
    case 'S': 
      final SslHandler ssl = new SslHandler(sslEngine);
      ctx.pipeline().replace(this, "tls", ssl);
      ssl.handshakeFuture().addListener(new GenericFutureListener<Future<? super Channel>>() {
        @Override
        public void operationComplete(final Future<? super Channel> future) throws Exception {
          ctx.pipeline().addLast(new PostgreSQLDecoder());
          ctx.pipeline().addLast(new PostgreSQLEncoder());
          ctx.pipeline().addLast(new LoggingHandler(PgConnection.class, LogLevel.DEBUG));
          ctx.pipeline().addLast(new PostgreSQLClientNegotiation(params, password));
          ctx.pipeline().addLast(handler);
        }
      });
      return;
    }
    // an error occured.
    log.error("SSL rejected, continuing without ...");
    ctx.pipeline().remove(this);
    ctx.pipeline().addLast(new LoggingHandler(PgConnection.class, LogLevel.DEBUG));
    ctx.pipeline().addLast(new PostgreSQLDecoder());
    ctx.pipeline().addLast(new PostgreSQLEncoder());
    ctx.pipeline().addLast(new PostgreSQLClientNegotiation(params, password));
    ctx.pipeline().addLast(handler);
  }

  private void initialize(final ChannelHandlerContext ctx) {
    final ByteBuf buf = ctx.alloc().buffer(8);
    buf.writeInt(8);
    buf.writeInt(ProtoUtils.SSL_MAGIC);
    ctx.writeAndFlush(buf);
  }

  private void destroy() {
  }

  @Override
  public void handlerAdded(final ChannelHandlerContext ctx) throws Exception {
    if (ctx.channel().isActive() && ctx.channel().isRegistered()) {
      // channelActvie() event has been fired already, which means this.channelActive() will
      // not be invoked. We have to initialize here instead.
      initialize(ctx);
    } else {
      // channelActive() event has not been fired yet. this.channelActive() will be invoked
      // and initialization will occur there.
    }
    super.handlerAdded(ctx);
  }

  @Override
  public void handlerRemoved(final ChannelHandlerContext ctx) throws Exception {
    destroy();
    super.handlerRemoved(ctx);
  }

  @Override
  public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {
    // Initialize early if channel is active already.
    if (ctx.channel().isActive()) {
      initialize(ctx);
    }
    super.channelRegistered(ctx);
  }

  @Override
  public void channelActive(final ChannelHandlerContext ctx) throws Exception {
    initialize(ctx);
    super.channelActive(ctx);
  }

  @Override
  public void channelInactive(final ChannelHandlerContext ctx) throws Exception {
    destroy();
    super.channelInactive(ctx);
  }
}
